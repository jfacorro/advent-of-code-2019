(ns advent.day-13
  (:require [advent.utils :as u]
            [advent.day-5 :as day-5]
            [clojure.string :as str]))

;; -----------------------------------------------------------------------------
;; Part One
;; -----------------------------------------------------------------------------

;; 0 is an empty tile. No game object appears in this tile.
;; 1 is a wall tile. Walls are indestructible barriers.
;; 2 is a block tile. Blocks can be broken by the ball.
;; 3 is a horizontal paddle tile. The paddle is indestructible.
;; 4 is a ball tile. The ball moves diagonally and bounces off objects.

(def EMTPY  0)
(def WALL   1)
(def BLOCK  2)
(def PADDLE 3)
(def BALL   4)

(defn read-msg []
  (receive* #erl[:out x] x))

(defn read-char []
  (try
    (read)
    (catch _ _
        (read-char))))

(defn send-msg [pid x]
  (erlang/send pid #erl[:out x]))

(defn compute-program
  [{:keys [parent program]}]
  (binding [*in* (new erlang.io.PushbackReader *in*)]
    (day-5/with-write-fn #(send-msg parent %)
      (day-5/with-read-fn read-char
        (day-5/compute program 0)))))

(defn run-program
  [{:keys [parent] :as state}]
  (compute-program state)
  ;; Signal the program is done
  (send-msg parent :done))

(defn spawn-program
  [parent program]
  (erlang/spawn #(run-program {:parent parent
                               :program program})))

(defn make-screen
  [w h]
  (->> (repeat w 0)
       vec
       (repeat h)
       vec))

(defn make-game
  []
  {:screen (make-screen 36 24) :score nil})

(defn render
  [{:keys [score screen]}]
  (doseq [line screen]
    (doseq [c line]
      (print (condp = c
               EMTPY  " "
               WALL   "|"
               BLOCK  "#"
               PADDLE "-"
               BALL   "O")))
    (println))
  (println "Score: " score))

(defn receive-ouput
  [game]
  (let [out (read-msg)]
    (if (= out :done)
      game
      (let [x out
            y (read-msg)
            tile-or-score (read-msg)]
        (if (= [x y] [-1 0])
          (let [game (assoc game :score tile-or-score)]
            (render game)
            (recur game))
          (let [game (assoc-in game [:screen y x] tile-or-score)]
            (when (and (:score game) (= tile-or-score BALL))
              (render game))
            (recur game)))))))

(defn count-tiles
  [{:keys [screen]} tile]
  (->> screen
       flatten
       (filter #(= % tile))
       count))

(defn input->program
  [input]
  (mapv erlang/binary_to_integer.1
        (-> input
            first
            (str/split ","))))

(defn part-one
  ([] (-> (u/input-for-day 13)
          input->program
          part-one))
  ([program]
   (spawn-program (erlang/self) program)
   (-> (make-game)
       receive-ouput
       (count-tiles BLOCK))))

;; -----------------------------------------------------------------------------
;; Part Two
;; -----------------------------------------------------------------------------

(defn part-two
  ([] (-> (u/input-for-day 13)
          input->program
          part-two))
  ([program]
   (spawn-program (erlang/self) (assoc program 0 2))
   (receive-ouput (make-game))
   nil))
